{
  "name": "Tictactoeai",
  "tagline": "Tic-Tac-Toe bot that will never lose, implemented with AI design MiniMax using Alpha-Beta pruning",
  "body": "# TicTacToeAI\r\n\r\nTic-Tac-Toe bot that will never lose, implemented with AI design MiniMax.\r\n\r\n### Overview\r\n\r\n* Built a Tic-Tac-Toe game for iPhone 4s.\r\n* Made the bot with different implementations:\r\n  1. Average score: the bot goes for the highest score available.\r\n  2. MiniMax score: the bot minimizes the player's score.\r\n  3. Alpha-Beta pruning: MiniMax with cut-offs to load the game faster.\r\n  4. (To-Do) Rotations and reflections: Alpha-Beta pruning with even more cut-offs by using symmetry.\r\n\r\n![TicTacToeAI With Alpha-Beta pruning](https://cloud.githubusercontent.com/assets/12219300/17765188/1ef01e52-64d9-11e6-8e27-c3e46e20d01a.gif)\r\n\r\n<!-- ![TicTacToeAI With Alpha-Beta pruning](https://cloud.githubusercontent.com/assets/12219300/17762272/d5e007b4-64c3-11e6-909d-f1bd0a185003.gif) -->\r\n\r\n## Creating the Bot\r\n\r\n![TicTacToe Possible Moves Tree](https://cloud.githubusercontent.com/assets/12219300/17765292/c83650a8-64d9-11e6-8039-93aff9365229.jpg)\r\n\r\nPhoto taken from http://www.devx.com/dotnet/Article/34912\r\n\r\nThe first implementation of the bot was done by making all the possible moves from the start to the finish and adding how the board looks like to a tree.\r\nThen, I added a variable to count just exactly how many boards are created, which turned out to be **986,410**.\r\nI checked it by deriving a formula from the pattern `1 + 9 + (9) * 8 + (9 * 8) * 7 + ... + 9!` which is `1 + Summation(9!/K!) where K = 0 to K = 8`, getting us 986,410 boards!\r\nSo, the initial loading time was pretty long because there were waaaay too many boards, but we were happy to see that at least we have a working tree.\r\nThe tree looks exactly like the picture above.\r\n\r\nNot all the possible moves are necessary because the game can end earlier if there is a winner.\r\nSo after adding a check to stop making boards when a winner is found, the amount of boards reduced to **549,945** and so did our initial loading time.\r\n\r\nAll the methods so far has been loading the entire tree at the initial load.\r\nSo with our method, it has a very long initial load but after the game is loaded, the bot moves instantly.\r\n\r\nIn order to make the initial load not so displeasing, [Alpha-Beta pruning](https://www.ocf.berkeley.edu/~yosenl/extras/alphabeta/alphabeta.html) technique was implemented with the MiniMax algorithm.\r\nInstead of checking for a winner like before, it checks for the scores that are given from the children tree and decides whether or not it needs to check other trees.\r\nThis reduced the amount of boards at initial load to **85,097**!\r\nWith this method, it was a faster initial load, with the downside of having to load every bot's turn, which wasn't bad because the number of boards needed to make for future moves are a lot smaller.\r\n\r\nThis is an overestimated number of boards made with Alpha-Beta pruning at every round.\r\n\r\nRound   |  # of boards\r\n---     | ---\r\n1       | 85,097\r\n2       | ~22,000\r\n3       | ~3,500\r\n4       | ~1,000\r\n5       | ~200\r\n6       | ~70\r\n7       | ~20\r\n8       | ~5\r\n9       | <= 1\r\nTotal   | **~111,000**\r\n\r\nHere's a rough comparison between each implementation with the iPhone 4s simulator on my MacBook.\r\n\r\nAlgorithm  | # of boards  |  Initial loading speed (seconds) | 1st round loading speed (seconds) | 2nd round loading speed (seconds)\r\n---        | ---          | ---                              | ---                               | ---\r\nAll possible moves  | 986,410 |  15 s | 0 s | 0 s\r\nAll possible moves w/ checks for winner  | 549,945 | 9 s| 0 s | 0 s\r\nAlpha-Beta pruning | 111,000 | 0 s | 1.5 s | 0.4 s\r\n\r\n## Scoring the Bot\r\n\r\n![Scoring picture](https://cloud.githubusercontent.com/assets/12219300/17835933/80bf37bc-6736-11e6-9aca-f5612ccd4573.jpg)\r\n\r\nPhoto taken from http://users.sussex.ac.uk/~christ/crs/kr-ist/lec05a.html\r\n\r\nWe have a tree where each depth represents a move made on the board.\r\nThe scores are calculated at the leaf nodes when the game ends, returning a score of 1 if the bot wins, 0 for a tie, and -1 for a loss. This is known as the **static score**.\r\nThen the scores are passed to the parents until it reached the root node.\r\n\r\n#### ~~Average Score~~\r\n\r\n![Average score error](https://cloud.githubusercontent.com/assets/12219300/17845944/723258d6-67fa-11e6-855c-02f494d717d2.jpeg)\r\n\r\nPicture credit: [Alaric](https://github.com/AlaricGonzales)\r\n\r\nThe first idea was to select the highest average scores from the children nodes to get the best possible chance of winning.\r\nThe idea was that the children with the higher average score will lead to higher chance of winning.\r\nWhile this is true, **it didn't create an unbeatable Tic-Tac-Toe**.\r\nIt made the bot too focused on selecting the moves that leads it to higher chances of victory.\r\nWhat this means is that, even if the opponent is about to win in the next turn, the bot will continue to go towards a move where it *CAN* lead to higher chances of winning instead of blocking.\r\nBecause the bot doesn't block the opponent's moves, the bot often loses and was not unbeatable as we wanted it to be.\r\n\r\n#### MiniMax Score\r\n\r\nMiniMax is the idea of minimizing the opponent's maximum score.\r\nIt goes like this:\r\n * Build the game tree. The static scores are determined at the leaf nodes.\r\n * Start traversing back, passing scores to each parent nodes.\r\n * The bot node will pick the highest score from children.\r\n * The player node will pick the smallest score from children.\r\n\r\nSo the bot will pick moves that will give the opponent the lowest score possible, thus maximizing the bot's own score.\r\nBy using this method, the bot will continuously block the opponent's moves, preventing them from winning, while also going for any possible victories.\r\nAs a result, using the MiniMax algorithm allowed us to create an unbeatable bot in Tic-Tac-Toe.\r\n\r\n#### Alpha-Beta Pruning\r\n\r\nAlpha-Beta pruning is a way of reducing the amount of search by not exploring the child nodes that will never be searched.\r\nThis is done by having two variables with given names *alpha* and *beta* to keep track of scores for alpha-cutoff and beta-cutoff.\r\nChris Thronton explains in [his lecture](http://users.sussex.ac.uk/%7Echrist/crs/kr-ist/lec05a.html):\r\n> * Applying an **alpha-cutoff** means we stop search of a particular branch because we see that we already have a better opportunity elsewhere.\r\n> * Applying a **beta-cutoff** means we stop search of a particular branch because we see that the opponent already has a better opportunity elsewhere.\r\n\r\nSo where does Alpha-Beta pruning come in?\r\nAs an example, let's say it's the bot's turn and that it has two children.\r\n\r\n 1. Bot's turn, `root` node: Wants to pick the highest score from children. It will populate the first child node, call it `A`, and get it's score. Next, it will have to find the score for the second child, call it `B`.\r\n\r\n 2. Opponent's turn, node `B`: Wants to pick the lowest score from children. It has 3 child `B1, B2, B3`. It wants to iterate through each one of those to get the lowest score *BUT* it also knows that **the biggest score that the `root` node has found is from node `A`**. It will also pass that biggest score as argument to each of the children.\r\n\r\n 3. Bot's turn, node `B1`: Wants to pick the highest score. Re-iteration of step 1 and returns the biggest score to node `B`.\r\n\r\n 4. Opponent's turn, back to node `B`: Now we have the score of `B1`. If the score of `B1` is smaller than the score from `root` node, then it doesn't have to search child nodes `B2` and  `B3`. The node `B` will pick a score from `B1` or smaller and the `root` node will pick a score bigger than score from `B1`. Because of that, the `root` node will end up never picking from the node `B`.\r\n\r\nSo cutoffs happen when **alpha >= beta**.\r\nAlpha is the biggest score that the `root` node might pick and beta is the smallest score that the `B` might pick.\r\nThen `B1, B2, B3` can sets the highest alpha.\r\n`B` compares if `B1` alpha is bigger than or equal to `B` beta and decides to do a cutoff if it does.\r\n\r\nThis [Alpha-Beta pruning practice](http://inst.eecs.berkeley.edu/~cs61b/fa14/ta-materials/apps/ab_tree_practice/) is a very neat tool that can help visualize how the process goes.\r\n\r\n---\r\n\r\n### Acknowledgements\r\nMy mentor [Rey](https://github.com/reygonzales) for guiding us through the assignment. This assignment was done together with [Alaric](https://github.com/AlaricGonzales) at our internship at PlanChat.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}